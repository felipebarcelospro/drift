# Entity Basics in Drift KV

Entities are the core building blocks in Drift KV, representing your data models and providing a type-safe interface for database operations.

## Defining an Entity

```typescript
import { DriftEntity } from "drift-kv";
import { z } from "zod";

const UserEntity = new DriftEntity({
  name: "user",
  description: "User entity with role-based access control",
  schema: z.object({
    id: z.string().uuid(),
    name: z.string().min(3).max(100),
    email: z.string().email(),
    role: z.enum(["admin", "user"]).default("user"),
    createdAt: z.date(),
    updatedAt: z.date(),
  }),
  options: {
    timestamps: true,
    indexes: ["email", "role"],
  },
  hooks: {
    beforeCreate: async (data) => {
      // Validation or transformation logic
    },
    afterCreate: async (result) => {
      // Post-creation processing
    },
  },
});
```

## CRUD Operations

### Create

```typescript
const newUser = await UserEntity.create({
  data: {
    id: crypto.randomUUID(),
    name: "John Doe",
    email: "john@example.com",
    role: "user",
  },
  select: {
    id: true,
    name: true,
    email: true,
  },
});
```

### Read

```typescript
// Find unique
const user = await UserEntity.findUnique({
  where: { id: "123" },
  select: {
    name: true,
    email: true,
  },
});

// Find many
const users = await UserEntity.findMany({
  where: {
    role: "admin",
    email: { contains: "@example.com" },
  },
  orderBy: {
    createdAt: "desc",
  },
  take: 10,
  skip: 0,
});
```

### Update

```typescript
const updatedUser = await UserEntity.update({
  where: { id: "123" },
  data: {
    name: "John Smith",
    role: "admin",
  },
  select: {
    id: true,
    name: true,
    role: true,
  },
});
```

### Delete

```typescript
const deletedUser = await UserEntity.delete({
  where: { id: "123" },
});
```

## Query Options

### Where Clauses

```typescript
// Basic conditions
const users = await UserEntity.findMany({
  where: {
    role: "admin",
    email: { contains: "@example.com" },
  },
});

// Complex conditions
const users = await UserEntity.findMany({
  where: {
    AND: [
      { role: "admin" },
      { 
        OR: [
          { email: { contains: "@company.com" } },
          { name: { startsWith: "John" } },
        ],
      },
    ],
    NOT: {
      status: "inactive",
    },
  },
});
```

### Select and Include

```typescript
const user = await UserEntity.findUnique({
  where: { id: "123" },
  select: {
    id: true,
    name: true,
    email: true,
  },
  include: {
    posts: {
      select: {
        title: true,
        content: true,
      },
      where: {
        published: true,
      },
      orderBy: {
        createdAt: "desc",
      },
      take: 5,
    },
  },
});
```

### Ordering and Pagination

```typescript
const users = await UserEntity.findMany({
  orderBy: {
    createdAt: "desc",
    name: "asc",
  },
  skip: 0,   // Skip first N records
  take: 10,  // Take N records
});
```

### Distinct

```typescript
const users = await UserEntity.findMany({
  distinct: ["role", "status"],
  select: {
    role: true,
    status: true,
  },
});
```

## Entity Hooks

Hooks allow you to intercept and modify entity operations:

```typescript
const UserEntity = new DriftEntity({
  // ...
  hooks: {
    beforeCreate: async (data) => {
      // Validate or transform data before creation
      data.email = data.email.toLowerCase();
      return data;
    },
    afterCreate: async (result) => {
      // Process after creation
      await sendWelcomeEmail(result.email);
      return result;
    },
    beforeUpdate: async (data) => {
      // Validate or transform data before update
      data.updatedAt = new Date();
      return data;
    },
    afterUpdate: async (result) => {
      // Process after update
      await invalidateCache(result.id);
      return result;
    },
    beforeDelete: async (id) => {
      // Validate or process before deletion
      await checkDeletionPermissions(id);
    },
    afterDelete: async (result) => {
      // Cleanup after deletion
      await cleanupRelatedData(result.id);
      return result;
    },
  },
});
```

## Entity Options

### Timestamps

Enable automatic timestamp management:

```typescript
const UserEntity = new DriftEntity({
  // ...
  options: {
    timestamps: true,  // Adds createdAt and updatedAt
  },
});
```

### Indexes

Define indexes for better query performance:

```typescript
const UserEntity = new DriftEntity({
  // ...
  options: {
    indexes: ["email", "role", "createdAt"],
  },
});
```

## Type Safety

Drift KV provides full type safety through TypeScript and Zod:

```typescript
// Define schema with Zod
const userSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(3),
  email: z.string().email(),
});

// Infer TypeScript type
type User = z.infer<typeof userSchema>;

// Type-safe operations
const user: User = await UserEntity.create({
  data: {
    id: crypto.randomUUID(),
    name: "John",    // Type checked
    email: "john@example.com",  // Type checked
    invalid: true,   // TypeScript error!
  },
});
```

## Error Handling

```typescript
try {
  const user = await UserEntity.create({
    data: {
      name: "Jo",  // Will fail validation (min 3 chars)
      email: "invalid-email",  // Will fail validation
    },
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation failed:", error.message);
  } else if (error instanceof QueryError) {
    console.error("Query failed:", error.message);
  } else {
    console.error("Unknown error:", error);
  }
}
```

## Best Practices

1. **Schema Design**
   - Define clear and specific schemas
   - Use appropriate Zod validators
   - Consider adding custom validators

2. **Query Optimization**
   - Use selective queries (select only needed fields)
   - Implement proper indexes
   - Use pagination for large datasets

3. **Hook Implementation**
   - Keep hooks focused and lightweight
   - Implement proper error handling
   - Consider performance impact

4. **Type Safety**
   - Leverage TypeScript's type system
   - Use Zod for runtime validation
   - Keep types in sync with schema

## Next Steps

- Learn about [Entity Relationships](./relationships.md)
- Explore [Querying](./querying.md)
- Understand [Validation](./validation.md)
- Implement [Real-time Features](../real-time/subscriptions.md)
