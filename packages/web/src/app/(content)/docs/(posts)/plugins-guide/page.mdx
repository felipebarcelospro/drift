# Plugins Guide for Drift KV

Plugins are an essential part of Drift KV that allow you to extend and customize its functionality to meet your specific needs. Plugins in Drift KV provide hooks and a consistent interface to manipulate different aspects of the lifecycle of database operations, making them a powerful tool for developers. This guide will help you understand how to create and use plugins effectively.

## Introduction to Plugins
Drift KV uses plugins to allow you to extend its functionality. Plugins can:
- **Add new behaviors** to database operations.
- **Hook into lifecycle events** such as queries, connections, and transactions.
- **Provide utilities** for commonly required features like logging or caching.

Plugins can be useful in scenarios such as:
- Logging every query to an external service.
- Caching specific query results to improve performance.
- Sending notifications when particular database actions occur.

## Creating a Custom Plugin
To create a custom plugin for Drift KV, you need to create an instance of the `Plugin` class, which is part of the core library. Below is an example of how to create a custom logger plugin:

```typescript
import { Plugin } from "drift-kv";

const loggerPlugin = new Plugin({
  name: "logger",
  description: "Logger plugin for tracking operations and debugging",
  config: {
    enabled: true,
    logLevel: "info",
    format: "json",
    destination: "console",
  },
  hooks: {
    onConnect: async (client, context) => {
      console.log("Logger connected:", client);
      await context.initializeLogger();
    },
    onDisconnect: async () => {
      console.log("Logger disconnected.");
    },
    onError: async (error) => {
      console.error("Logger error:", error);
    },
  },
  query: {
    intercept: (query, context) => {
      return {
        beforeExecute: async () => {
          console.log("Before query execution:", query);
        },
        afterExecute: async (result) => {
          console.log("After query execution:", { query, result });
          return result;
        },
      };
    },
  },
});
```

### Key Elements of a Plugin
- **Name and Description**: Every plugin must have a unique name and a clear description of its purpose.
- **Configuration**: Plugins can have configuration options to enable or disable certain features.
- **Hooks**: Hooks are methods that run at different stages of a plugin's lifecycle (e.g., connection, disconnection, errors).
- **Query Interception**: Plugins can intercept queries before and after execution, allowing for custom behavior to be injected.

## Plugin Lifecycle Hooks
Drift KV provides several hooks that you can leverage when creating plugins. Hooks allow you to run custom code at different points of a plugin's lifecycle:

- **onConnect(client, context)**: Triggered when the database connection is established.
- **onDisconnect()**: Triggered when the database connection is closed.
- **onError(error)**: Triggered when an error occurs in the plugin.
- **beforeQuery(query)**: Runs before a query is executed.
- **afterQuery(result)**: Runs after a query has been executed.

These hooks make it possible to introduce custom logic at critical points of database operations.

## Using Plugins in Drift
To use a plugin, you need to add it to your Drift instance's configuration. Here's how you can do that:

```typescript
import { Drift } from "drift-kv";
import { loggerPlugin } from "./plugins/LoggerPlugin";

const client = Deno.openKv();

const drift = new Drift({
  client,
  plugins: [loggerPlugin],
});
```
By adding the plugin to the `plugins` array, Drift will manage the plugin's lifecycle automatically, running its hooks as appropriate.

## Example Plugins
Here are two example plugins: a **Logger Plugin** and a **Cache Plugin**.

### Logger Plugin
The **Logger Plugin** is used to track operations and log them to the console or another specified destination. It helps with debugging and provides insight into the sequence of operations.

```typescript
import { Plugin } from "drift-kv";

const loggerPlugin = new Plugin({
  name: "logger",
  description: "Logger plugin for tracking database operations",
  config: {
    enabled: true,
    logLevel: "info",
    format: "json",
    destination: "console",
  },
  hooks: {
    onConnect: async (client, context) => {
      console.log("Database connected:", client);
    },
    onDisconnect: async () => {
      console.log("Database disconnected.");
    },
    onError: async (error) => {
      console.error("Database error:", error);
    },
  },
  query: {
    intercept: (query, context) => {
      return {
        beforeExecute: async () => {
          console.log("Executing query:", query);
        },
        afterExecute: async (result) => {
          console.log("Query result:", result);
          return result;
        },
      };
    },
  },
});
```

### Cache Plugin
The **Cache Plugin** is used to cache query results for performance improvement. This can help reduce the load on the database for frequently repeated queries.

```typescript
import { Plugin } from "drift-kv";

const cachePlugin = new Plugin({
  name: "cache",
  description: "Caching plugin for improved query performance",
  config: {
    enabled: true,
    defaultTTL: 1000 * 60 * 60, // Cache entries for 1 hour
    storage: "redis",
  },
  query: {
    intercept: (query, context) => {
      const cacheKey = `${query.entity}:${query.operation}:${JSON.stringify(query.params)}`;
      return {
        beforeExecute: async () => {
          const cachedResult = await context.cache.get(cacheKey);
          if (cachedResult) return cachedResult;
        },
        afterExecute: async (result) => {
          await context.cache.set(cacheKey, result);
          return result;
        },
      };
    },
  },
});
```

## Summary
Plugins in Drift KV are an extremely flexible way to extend the core features of the library and add custom behaviors to your database operations. Whether you're adding logging, caching, or creating custom notifications, the plugin system provides a structured way to do so without cluttering your main codebase.

For more detailed examples and additional documentation, please refer to our repository's plugins folder and API documentation.
