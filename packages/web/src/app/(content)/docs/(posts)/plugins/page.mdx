# Plugin System in Drift KV

Drift KV provides a powerful plugin system through the `DriftPlugin` class, allowing you to extend and customize the ORM's functionality. Plugins can intercept and modify database operations, add new features, and hook into various lifecycle events.

## Creating a Plugin

### Basic Plugin Structure

```typescript
import { DriftPlugin } from "drift-kv";

const loggerPlugin = new DriftPlugin({
  name: "logger",
  description: "Logging plugin for database operations",
  config: {
    enabled: true,
    logLevel: "info",
    format: "json",
  },
  hooks: {
    onConnect: async (client, context) => {
      console.log("Database connected:", client);
    },
    onDisconnect: async () => {
      console.log("Database disconnected");
    },
    onError: async (error) => {
      console.error("Database error:", error);
    },
  },
  methods: {
    log: (message: string) => {
      console.log(`[Logger] ${message}`);
    },
  },
});
```

## Plugin Lifecycle Hooks

### Available Hooks

```typescript
const monitoringPlugin = new DriftPlugin({
  name: "monitoring",
  hooks: {
    // Connection hooks
    onConnect: async (client, context) => {
      // Called when database connection is established
    },
    onDisconnect: async () => {
      // Called when database connection is closed
    },
    
    // Query hooks
    beforeQuery: async (query, context) => {
      // Called before executing a query
      console.time(`query-${query.id}`);
    },
    afterQuery: async (result, context) => {
      // Called after query execution
      console.timeEnd(`query-${query.id}`);
    },
    
    // Error handling
    onError: async (error) => {
      // Called when an error occurs
      await reportError(error);
    },
  },
});
```

## Query Interception

### Intercepting Queries

```typescript
const cachePlugin = new DriftPlugin({
  name: "cache",
  config: {
    ttl: 3600, // 1 hour
  },
  query: {
    intercept: (query, context) => {
      return {
        beforeExecute: async () => {
          // Check cache before query execution
          const cacheKey = generateCacheKey(query);
          const cached = await cache.get(cacheKey);
          if (cached) return cached;
        },
        afterExecute: async (result) => {
          // Store result in cache
          const cacheKey = generateCacheKey(query);
          await cache.set(cacheKey, result, context.config.ttl);
          return result;
        },
      };
    },
  },
});
```

## Real-world Plugin Examples

### Logging Plugin

```typescript
const loggerPlugin = new DriftPlugin({
  name: "logger",
  config: {
    level: "info",
    destination: "console",
  },
  hooks: {
    beforeQuery: async (query, context) => {
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] Executing query:`, {
        action: query.action,
        entity: query.entity,
        params: query.params,
      });
    },
    afterQuery: async (result, context) => {
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] Query result:`, {
        success: true,
        resultCount: Array.isArray(result) ? result.length : 1,
      });
    },
    onError: async (error) => {
      const timestamp = new Date().toISOString();
      console.error(`[${timestamp}] Error:`, {
        name: error.name,
        message: error.message,
        stack: error.stack,
      });
    },
  },
});
```

### Caching Plugin

```typescript
const cachePlugin = new DriftPlugin({
  name: "cache",
  config: {
    enabled: true,
    ttl: 3600,
    storage: "redis",
  },
  hooks: {
    onConnect: async (client, context) => {
      // Initialize cache connection
      await context.cache.connect();
    },
    onDisconnect: async () => {
      // Close cache connection
      await context.cache.disconnect();
    },
  },
  query: {
    intercept: (query, context) => {
      const cacheKey = `${query.entity}:${query.action}:${JSON.stringify(query.params)}`;
      
      return {
        beforeExecute: async () => {
          if (!context.config.enabled) return;
          
          const cached = await context.cache.get(cacheKey);
          if (cached) {
            return JSON.parse(cached);
          }
        },
        afterExecute: async (result) => {
          if (!context.config.enabled) return result;
          
          await context.cache.set(
            cacheKey,
            JSON.stringify(result),
            context.config.ttl
          );
          
          return result;
        },
      };
    },
  },
});
```

### Metrics Plugin

```typescript
const metricsPlugin = new DriftPlugin({
  name: "metrics",
  config: {
    collectInterval: 5000,
  },
  hooks: {
    onConnect: async () => {
      metrics.gauge("drift_connections", 1);
    },
    onDisconnect: async () => {
      metrics.gauge("drift_connections", 0);
    },
    beforeQuery: async (query) => {
      metrics.increment(`drift_queries_${query.action}`);
    },
    afterQuery: async (result) => {
      metrics.histogram("drift_query_results", 
        Array.isArray(result) ? result.length : 1
      );
    },
    onError: async (error) => {
      metrics.increment(`drift_errors_${error.name}`);
    },
  },
});
```

## Plugin Configuration

### Configuration Options

```typescript
const plugin = new DriftPlugin({
  name: "customPlugin",
  config: {
    enabled: true,
    options: {
      // Custom configuration options
      timeout: 5000,
      retries: 3,
      features: {
        caching: true,
        logging: false,
      },
    },
  },
});
```

### Dynamic Configuration

```typescript
const plugin = new DriftPlugin({
  name: "dynamicPlugin",
  config: {
    get timeout() {
      return process.env.PLUGIN_TIMEOUT || 5000;
    },
    get features() {
      return {
        caching: process.env.ENABLE_CACHE === "true",
        logging: process.env.NODE_ENV === "development",
      };
    },
  },
});
```

## Best Practices

1. **Plugin Design**
   - Keep plugins focused and single-purpose
   - Implement proper error handling
   - Use TypeScript for type safety

2. **Performance**
   - Minimize overhead in hooks
   - Implement caching when appropriate
   - Monitor plugin impact

3. **Error Handling**
   - Handle all possible error scenarios
   - Provide meaningful error messages
   - Avoid swallowing errors

4. **Configuration**
   - Make plugins configurable
   - Provide sensible defaults
   - Document configuration options

## Next Steps

- Learn about [Entity Management](../entities/basics.md)
- Explore [Job Queues](../job-queues/index.md)
- Understand [Real-time Features](../real-time/subscriptions.md)
- Review [Performance Optimization](../advanced/performance.md)
