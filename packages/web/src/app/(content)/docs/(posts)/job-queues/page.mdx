# Job Queues in Drift KV

Drift KV provides a robust job queue system through the `DriftQueue` class, enabling background processing, scheduled tasks, and reliable task execution with retry mechanisms.

## Basic Queue Setup

```typescript
import { DriftQueue } from "drift-kv";
import { z } from "zod";

// Define a queue for email processing
const emailQueue = new DriftQueue({
  name: "email",
  description: "Queue for processing email notifications",
  schema: z.object({
    to: z.string().email(),
    subject: z.string(),
    body: z.string(),
    attachments: z.array(z.string().url()).optional(),
  }),
  options: {
    retryAttempts: 3,
    timeout: 5000,
  },
  handler: async (job) => {
    await sendEmail(job.data);
  },
});
```

## Queue Configuration

### Options

```typescript
const imageProcessingQueue = new DriftQueue({
  name: "image-processing",
  schema: imageJobSchema,
  options: {
    // Number of retry attempts for failed jobs
    retryAttempts: 3,
    
    // Timeout in milliseconds
    timeout: 30000,
    
    // Concurrency limit
    concurrency: 5,
  },
  hooks: {
    onBeforeEnqueue: async (data) => {
      // Pre-enqueue validation or transformation
    },
    onStart: async (data) => {
      // Job start handling
    },
    onSuccess: async (data) => {
      // Success handling
    },
    onError: async (error, data) => {
      // Error handling
    },
    onEnd: async () => {
      // Cleanup
    },
  },
});
```

## Job Processing

### Enqueuing Jobs

```typescript
// Add a job to the queue
await emailQueue.schedule({
  job: "sendWelcomeEmail",
  data: {
    to: "user@example.com",
    subject: "Welcome to Drift KV",
    body: "Thank you for joining us!",
  },
});

// Add multiple jobs
await Promise.all([
  emailQueue.schedule({
    job: "notification",
    data: notification1,
  }),
  emailQueue.schedule({
    job: "notification",
    data: notification2,
  }),
]);
```

### Processing Jobs

```typescript
// Start processing jobs
await emailQueue.process({
  concurrency: 5,
  timeout: 10000,
  onWorkerStart: async () => {
    console.log("Worker started");
  },
  onWorkerEnd: async () => {
    console.log("Worker finished");
  },
  onWorkerError: async (error) => {
    console.error("Worker error:", error);
  },
  onJobStart: async (job) => {
    console.log("Starting job:", job.id);
  },
});
```

## Error Handling and Retries

```typescript
const emailQueue = new DriftQueue({
  name: "email",
  schema: emailSchema,
  options: {
    retryAttempts: 3,
  },
  hooks: {
    onError: async (error, data) => {
      if (error.code === "SMTP_ERROR") {
        // Handle SMTP errors
        await notifyAdmin(error);
      }
      
      // Log error details
      await logError({
        queue: "email",
        error,
        data,
      });
    },
  },
  handler: async (job) => {
    try {
      await sendEmail(job.data);
    } catch (error) {
      // Job will be retried based on retryAttempts
      throw new Error("Failed to send email: " + error.message);
    }
  },
});
```

## Real-world Examples

### Image Processing Queue

```typescript
const imageQueue = new DriftQueue({
  name: "image-processing",
  schema: z.object({
    imageUrl: z.string().url(),
    sizes: z.array(z.number()),
    format: z.enum(["jpeg", "webp", "png"]),
    quality: z.number().min(1).max(100),
  }),
  options: {
    retryAttempts: 2,
    timeout: 60000, // 1 minute
  },
  hooks: {
    onBeforeEnqueue: async (data) => {
      // Validate image URL
      const exists = await checkImageExists(data.imageUrl);
      if (!exists) {
        throw new Error("Image not found");
      }
    },
    onStart: async (data) => {
      await updateJobStatus(data.id, "processing");
    },
    onSuccess: async (data) => {
      await updateJobStatus(data.id, "completed");
    },
    onError: async (error, data) => {
      await updateJobStatus(data.id, "failed");
      await notifyAdmin({
        type: "image-processing-failed",
        data,
        error,
      });
    },
  },
  handler: async (job) => {
    const { imageUrl, sizes, format, quality } = job.data;
    
    // Process image for each size
    const results = await Promise.all(
      sizes.map(size => 
        processImage({
          url: imageUrl,
          size,
          format,
          quality,
        })
      )
    );
    
    return results;
  },
});
```

### Data Export Queue

```typescript
const exportQueue = new DriftQueue({
  name: "data-export",
  schema: z.object({
    userId: z.string().uuid(),
    format: z.enum(["csv", "json", "xlsx"]),
    filters: z.record(z.unknown()).optional(),
    notifyEmail: z.string().email(),
  }),
  options: {
    retryAttempts: 1,
    timeout: 300000, // 5 minutes
  },
  hooks: {
    onStart: async (data) => {
      await updateExportStatus(data.userId, "processing");
    },
    onSuccess: async (data) => {
      await updateExportStatus(data.userId, "completed");
      await emailQueue.schedule({
        job: "exportComplete",
        data: {
          to: data.notifyEmail,
          subject: "Your export is ready",
          body: "Your data export has been completed...",
        },
      });
    },
    onError: async (error, data) => {
      await updateExportStatus(data.userId, "failed");
      await emailQueue.schedule({
        job: "exportFailed",
        data: {
          to: data.notifyEmail,
          subject: "Export failed",
          body: `Your data export failed: ${error.message}`,
        },
      });
    },
  },
  handler: async (job) => {
    const { userId, format, filters } = job.data;
    
    // Fetch data
    const data = await fetchUserData(userId, filters);
    
    // Format data
    const formatted = await formatData(data, format);
    
    // Store result
    const fileUrl = await storeExport(formatted, userId);
    
    return { fileUrl };
  },
});
```

## Performance Optimization

### Batch Processing

```typescript
const notificationQueue = new DriftQueue({
  name: "notifications",
  schema: notificationSchema,
  options: {
    batchSize: 100,
    processingInterval: 5000, // Process every 5 seconds
  },
  handler: async (jobs) => {
    // Process jobs in batches
    const notifications = jobs.map(job => job.data);
    await sendBatchNotifications(notifications);
  },
});
```

### Resource Management

```typescript
const videoQueue = new DriftQueue({
  name: "video-processing",
  schema: videoSchema,
  options: {
    concurrency: 2, // Limit concurrent processing
    memoryLimit: 1024 * 1024 * 512, // 512MB limit
  },
  hooks: {
    onStart: async (data) => {
      // Allocate resources
      await acquireResources(data);
    },
    onEnd: async () => {
      // Release resources
      await releaseResources();
    },
  },
});
```

## Best Practices

1. **Job Design**
   - Keep jobs focused and single-purpose
   - Include all necessary data in job payload
   - Implement proper validation

2. **Error Handling**
   - Use appropriate retry strategies
   - Implement proper error logging
   - Handle edge cases

3. **Resource Management**
   - Control concurrency appropriately
   - Implement proper cleanup
   - Monitor resource usage

4. **Monitoring**
   - Track job completion rates
   - Monitor queue lengths
   - Set up alerting for failures

## Next Steps

- Learn about [Plugins](../plugins/index.md)
- Explore [Real-time Features](../real-time/subscriptions.md)
- Understand [Error Handling](../advanced/error-handling.md)
- Review [Performance Optimization](../advanced/performance.md)
